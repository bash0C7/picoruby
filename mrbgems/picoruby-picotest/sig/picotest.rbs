type picotest_error_t = {
  success: Integer,
  failure: Integer,
  errors: Array[Hash[untyped, untyped]]
}

$picotest_result: Hash[String, picotest_error_t]

module Picotest
  GREEN: String
  RED: String
  RESET: String

  class Double
    type type_t = :stub | :mock
    type double_data_t = {
      type: type_t,
      doubled_obj_id: Integer,
      method_id: Symbol?,
      return_value: untyped,
      singleton_class_name: String?,
      ?expected_count: Integer,
      ?actual_count: Integer
    }
    attr_accessor double_data: double_data_t
    attr_accessor doubled_obj: untyped
    attr_accessor singleton_class_name: String
    @method_id: Symbol
    def self.alloc: (type_t type, untyped untyped) -> Double
    private def self._alloc: (untyped untyped) -> Double
    private def self.get_double_methods: () -> Array[double_data_t]
    private def _define_method: (Symbol method_id, untyped doubled_obj) -> String
    private def method_missing: (?Symbol method_id, ?Integer expected_count) { () -> void } -> void
    def remove_singleton: () -> nil
  end

  class Test
    @doubles: Array[Double]
    def list_tests: () -> Array[Symbol]
    def assert:(bool result) -> void
    def assert_nil: (untyped obj) -> void
    def assert_equal: (untyped expected, untyped actual) -> void
    def assert_raise: (untyped exception, ?(String | nil) message) { () -> void } -> void
    private def report: (bool result, String | nil error_message, untyped expected, untyped actual) -> void
  end

  class Runner
    def self.run: (String dir, ?(String | nil) filter) -> void
    private def self.summerize: () -> Integer
    private def self.load_tests: (Array[untyped] entries) -> void
    private def self.find_tests: (String dir, (String | nil) filter) -> Array[Symbol]
  end
end

# @private
class Object
  def self.constants: () -> Array[Symbol]
end
